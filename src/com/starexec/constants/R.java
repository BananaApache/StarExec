package com.starexec.constants;

import java.lang.reflect.Field;
import java.util.ResourceBundle;

import org.apache.log4j.Logger;


/**
 * Class which holds static resources (R) available for use
 * throughout the entire application. This will include many
 * constant strings and numbers that other classes rely on.
 * @author Tyler Jensen
 */
public class R {
	/* 
	 * IMPORTANT: This class only supports string, int and boolean types.
	 * DO NOT change field names without changing their corresponding keys
	 * in starexec.properties. Field names must match property key names!
	 */
	private static final Logger log = Logger.getLogger(R.class);
	
	public R() throws Exception{
		throw new Exception("Cannot instantiate class because it is static.");
	}
	
	
	// MySQL properties
	// TODO: Crate a new MySQL account with limited privleges
	public static String MYSQL_URL = null;									// MySQL connection string for JDBC
	public static String MYSQL_USERNAME = null;								// Starexec's username for the database
	public static String MYSQL_PASSWORD = null;								// Starexec database password
	public static int CONNECTION_POOL_SIZE = -5;							// How many connections to keep available for use throughout
	
	// Global path information
	public static String SOLVER_PATH = null;								// The top-level directory in which to save the solver file(s)
	public static String BENCHMARK_PATH = null;								// The top-level directory in which to save the benchmark file(s)
	public static String STAREXEC_ROOT = null;								// The directory of the starexec webapp
	public static String CLASS_PATH = null;									// The directory of starexec's compiled classes
	public static String NODE_WORKING_DIR = null;							// The directory on the local nodes where they can use for scratch space (read/write)
	public static String JOB_INBOX_DIR = null;								// Where to deposit new job scripts until SGE distributes it to a node
    
    // Benchmark XML constants
    public static String BXML_OUTPUT_NAME = "output.xml";					// The output name for benchmark xml files generated by uploading a solver    	
	
	// Job Manager (JM) constants
	public static String JOBFILE_FORMAT = null;								// The filename format (with standard java string formatting) for generated jobscript files
	public static String SOLVER_BIN_DIR = null;								// The path to the bin directory to look for runscripts (relative to the solver's toplevel directory)
	public static int NEXT_JID = 1;											// The number of the next Job to be ran
	public static int PAIR_ID = 1;											// The number of the next pair to be ran
	
	// Job status strings
	public static String JOB_STATUS_DONE = "Done";							// The status of a successfully finished job
	public static String JOB_STATUS_RUNNING = "Running";					// The status of a currently running job
	public static String JOB_STATUS_ENQUEUED = "Enqueued";					// The status of a job that SGE has queued up to be run
	public static String JOB_STATUS_ERR = "Error";							// The status of a failed job
	
	// Misc application properties
	public static boolean LOG_TO_CONSOLE = true;							// Whether or not to output log messages to the console
	
	/**
	 * Loads resources from the starexec.properties file into the static resource class
	 * (com.starexec.constants.R) using reflection. The property file keys must match the
	 * corresponding field name in the R resource class.
	 */
	@SuppressWarnings("unchecked")
	public static void loadStarexecResources(){
		try {
			log.debug("Loading properties from starexec.properties");
			// Load the starexec.properties file (this searches for it automatically according to class loader path)
			ResourceBundle properties = ResourceBundle.getBundle("starexec");			
			
			// Get a reflected reference to the resource class
			Class<R> resourceClass = (Class<R>) Class.forName("com.starexec.constants.R");
			
			// For each property key in the loaded property file
			for(String key : properties.keySet()){
				try {
					// Get the field from the resource class that matches the property key
					Field field = resourceClass.getField(key);
					
					// Based on the type of field we're expecting, set that field's value to the property's value
					if(field.getType().equals(String.class)){
						field.set(null, properties.getString(key));
					} else if(field.getType().equals(int.class)){
						field.setInt(null, Integer.parseInt(properties.getString(key)));
					} else if(field.getType().equals(boolean.class)){
						field.set(null,Boolean.parseBoolean(properties.getString(key)));
					}	            
					
					log.debug(String.format("Loaded property [%s]: %s", key, field.get(null)));
				} catch (Exception e){
					log.error(String.format("Failed to load property [%s]. Error [%s]", key, e.getMessage()));
				}
			}
			log.debug("Property loading complete");
		} catch(Exception e) {
           log.fatal(e.getMessage(), e);
		}
	}
}
